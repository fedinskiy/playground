Проверять, какие методы доступны по ссылке на текущий класс
Проверять, срабатывает ли условие выхода из рекурсии
Проверять правильность лямбд
Если класс компилируется, то не надо забывать про этот вариант ответа)
Если нет реализации метода —— внутри может твориться что угодно
Проверять Paths или Path вызывается с методом
Читать заковыристые вопросы лучше
Какая бы хуйня не происходила — ты к этому готов. ищи знакомое
Проверять сигнатуры функций и наборы генериков
Дочитывать все варианты ответов
Проверять сколько вариантов ответов требуется, 1 раз — при чтении вопроса, и второй — в конце экзамена

База:
HashCode — вспомогательный для equals класс. То, что находится в нём, определяется тем, к чему обращается equals
composition позволяет лучшее переиспользование кода, чем наследование
Имена полей и методов в синглтонах необязательны
При проверке кастов компилятор смотрит на ссылку и не проверяет, что у неё внутри
null instanceOf X — компилируется, но выдает false
Если слева — интерфейс, то instanceOf всегда компилируется

Нельзя вызывать статические методы интерфейсов на объектах
Enum не могут быть локальными в методах
Enum можно иметь только private или package-private конструкторы. Вызывать их все равно можно только внутри класса
Конструкторы Enum не могут использовать нефинальные статические поля
Переменные в дочерних классах могут затирать родительские. при обращении к такой переменной значение имеет, по какой ссылке произошло обращение
При оверрайдинге метод не может принимать на вход иные параметры, чем отцовский
Внутренние, нестатические классы классов и методов не могут содержать static переменных и методов
Вызов конструкторов внутренних классов: outer.new Inner()
Анонимные классы могут наследовать обычным классам(например, если хочется добавить им новый метод)
Статические методы не могут затирать нестатические методы(ошибка компиляции). Обратное возможно
Методы, объявленные только в анонимных классах могут использоваться только сразу после создания класса, и не будут доступны по ссылке
Внутренние классы в классах могут быть абстрактными или даже финальными
Если в классе существуют два метода, отличающихся только генериками, то он не скомпилируется
Классы верхнего уровня не могут быть private или protected

Стримы:
Если в левой части лямбды 2 и больше параметров, то они обязаны иметь скобки, но не обязаны иметь тип
Параметры лямбды — не финальные
При вопросах про лямбды — смотреть, не перезатираются ли переменные снаружи
Проверять, не вызывается ли терминатор на стриме больше одного раза
Проверять, идёт ли вопрос про Stream(объектный) или про stream(объектный и примитивные)
Над открытым потоком можно работать несколько раз подряд, и если это поток мутабельных объектов, то изменения даже отразятся в последующих вызовах. Стандартные обертки — не мутабельные
filter всегда принимает на вход лямбду от одного значения, не от двух
IntFunction и прочие DoubleConsumer-ы принимают на вход примитивы(в отличие от остальных ФИ, которые принимают генерик классы)
Unchecked exceptions могут кидать кто угодно
Если функция принимает на вход функциональный интерфейс, то ей можно скормить ссылку на метод с подходящими входными и выходными значениями
Если функциональный интерфейс(например Callable) возвращает значение,то лямбда, которая его реализует, должна иметь return(даже если void)
Метод sorted в стримах работает либо с компаратором на входе, либо пытается скастить содержимое стрима в Comparable, если во время компиляции видно, что не получится — падает сразу же
Uppercase сортируется перед lowercase
У всех стримов есть методы max и min(требуют компаратор на вход)
Метод sum есть только у примитивных стримов, возвращает тот же тип, что и поток(а вот average возвращает OptionalX)
У Map есть метод foreach. Ждёт BiConsumer
Методы xMatch — работают ровно до того момента, когда могут стопроцентно определить результат выполнения

groupBy — метод в классе Collectors, а не у класса Stream
Collectors.mapping принимает на вход не только маппер, но ещё и другой коллектор
Collectors.counting()— именно то, что написано. возвращает Long
Collector.toMap падает, когда видит повторяющийся ключ. Лечиться добавлением функции-сращивателя значений
Collectors.joining имеет перегруженную версии: одну, умеющую в разделитель, и другую, умеющую в разделитель и в префикс с суффиксом(именно в таком порядке)
reduce над потоком X возвращает Optional<X>(версия с аккумулятором на входе), просто X(идентичность и аккумулятор), или Y(идентичность Y, функция из Y и X в Y, аккумулятор Y)
Функциональные интерфейсы должна быть типизированы
У компаратора есть метод thenComparing, который позволяет добавлять вложенные компараторы, может принимать сразу компаратор, либо функцию маппинга и  опциональный компаратор
Reduce-операцией считается такая, которая обязательно проходит по всем элементам стрима и прекращает его
У всех стримов есть метод forEachOrdered. Вне зависимости от того, параллелен/последователен стрим, всегда обрабатывает значения в исходном порядке
Лямбды можно вкладывать друг-в-друга и это пиздец


Коллекции:
Коллекции с вилдкартами(неограниченными или с верхней ("extends") границей) — иммутабельны с практической точки зрения(компилятор не позволит туда что-нибудь записать)
У листов есть метод replaceAll, мутирующий все элементы согласно переданному унарному оператору. А у наборов - нету
Collections.sort. спокойно работает с null компаратором(вторым параметром)

У Queue есть метод remove(Object)
Queue:
добавление в конец, вернуть успешность: add(с ошибкой), offer
получить первый: element(с ошибкой), peek
получить и удалить первый: remove(с ошибкой),poll(), pop(тоже только с ошибкой, есть только у deque)
Добавить в начало: push

Видим Navigable — читаем «сортированный»
У NavigableMap/Set есть метод tailX(a,b), который возвращает ссылку на кусок исходных данных(не копию!), начиная с элемента a, и если b — имеется и true, то включая этот элемент
Есть аналогичный метод subset(a,b,c,d), возвращающий подмножество
При вызове без булевых значений, возвращается SortedSet, с ними — Navigable
Оба подмножества кидают ошибки при добавлении в них элементов вне граничных значений.

У Map нет метода contains(только containsKey и containsValue)
map.put() возвращает старое знаечние по этому ключу или null
concurrentHashMap совсем не умеет в null-ы, кидает исключения
Как работает binarySearch — положительный индекс, если нашелся равный элемент и (-потенциальный индекс)-1, если не нашелся
List<Integer> l1 = new ArrayList(); — так можно

Локализация и обработка ошибок:
Создание локали — через new Locale("en", [?"US"])
Старые даты и времена — потокоопасные, новые — потокобезопасные, даже если это инстанты
LocalDate и друзья — неизменные. метод x.plusDay создает новый объект, а не меняет старый
Для получения ключей из properties используется метод keySet(а не keys)
Instant не хранит в себе текущую временную зону, он всегда рассчитан от GMT
Очередность загрузки бандлов: для каждого типа сначала ищем .class, потом properties. Порядок: язык и страна, только язык, дефолтная локаль, дефолтный язык, безлокальный(дефолтный) бандл,
MissingResourceException
У ResourceBundle есть метод getStringArray
Все подходящие бандлы загружаются сразу же
Дурацкое летнее время
Locale — это еще и enum
Ноль в Duration - это всегда секунды, а в Period — дни

Наследники AutoCloseable либо должны переопределять метод close c новым кидаемым исключением, либо вынуждать try-с-ресурсами ловить Exception
Объект внутри try() должен не только иметь метод close() но и реализовывать AutoCloseable)
Если хоть один объект создан в try-with то он будет закрыт
Объект в try() должен быть не только инициализирован, но и объявлен
AutoCloseable в try — финальное с т.з. компилятора

Некоторые наркоманские вещи могут работать в реальности: assert(x==1): "Текст ошибки" , например
После двоеточия в аасерте может быть что угодно, кроме void
assert появился в 1.4
Компилятору можно указывать версию кода
Для включения/отключения ассертов группами нужно использовать троеточие, а не звёздочку. Не действует на системные библиотеки, у них свои консольные параметры
Не следует проверять ассертами параметры публичных методов и пользовательский ввод

DateTimeParseException — это runtimeException
Можно писать throws для исключений, которые не кидаются
В мультикэтч нельзя класс и подкласс, даже если они кастомные :3

Concurrency:
создание параллельных потоков из потока: stream.parallel(), из коллекции: collection.parallelStream()
Редьюс на параллельном стриме может сработать странно, если нулевой элемент плохой

Создание executorService(и ScheduledExecutorService) только через фабричные методы Executors вида newX(). Если надо несколько тредов — то методы называются Pool
ExecutorService — потомок Executor, имеет метод submit(Callable)
invokeAll у экзекьютора - работает синхронно
execute(Runnable), submit(Callable), invokeX(Callable)
Если executor создан, но shutdown не вызван, то код зависнет
Неизвестно, сколько тредов выделяет JVM на parallelStream
static synchronized — лок на классе, а не на объекте
Skip* коллекции — просто сортированные многопоточные коллекции, без особых плюшек
Blocking коллекции — методы добавления и удаления могут ждать операцию некоторое время
У Atomic, методы, переиспользующие текущее значение обязательно используют *get
По расписанию: всё, что можно сделать с Callable в ScheduledExecutor — запланировать её однократное исполнение в будущем. Runnable можно запустить с отсрочкой, запустить каждые N(scheduleAtFixedRate) либо перезапускать иногда(scheduleAtFixedDelay)
Под капотом, метод start асинхронно запускает run и завершается
После метода start, вызвавший метод просто продолжает работать дальше
Каждый инстанс класса Random нормально работает при одновременном вызове из нескольких потоков, но делает это медленно. Предпочтительное решение: ThreadLocalRandom.current()
Инкеремент и декремент — не атомарные операции
RecursiveTask - возвращает значение, которым генерализован, внутри делает x.fork и x.join+y.compute
RecursiveAction — не возвращает, внутри создает подзадачи и вызывает invokeAll

IO
Методы PrintWriter не кидают checked ошибок, в отличие от методов обычного Writer. Вместо этого они пишут всё в черную книжечку и выводят при необходимости
Класса PrintReader не существует, System.console().reader() возвращает обычный Reader
У консоли есть непосредственно методы printf и format, но они не могут принимать на вход локаль, а используют системную
Метод readpassword есть у консоли, но отсутствует в ридере
static поля не сериализуются
Внутри readObject и writeObject неплохо бы вызывать методы stream.defaultWriteObject() и stream.defaultReadObject()
Десериализация не вызывает конструкторов и инициализацию полей
Метода copy у файлов нету, надо пользоваться потоками
Методы работы с файлами умеют работать с символическими ссылками, но не умеют в нормальный обход дерева
У InputStreamReader есть метод read, возвращающий int
Объекты класса File — иммутабельны

FileOutputStream по умолчанию переписывает весь файл полностью(даже если записывает меньшее число байт)
Если закрыть пустой пишущий поток, то он создаст пустой файл или сотрёт всю инфу из предыдущего

NIO2
Метод normalize и relativize не превращают относительный путь в абсолютный
toAbsolutePath, в свою очередь, не нормализует
При применении toAbsolutePath к относительному пути расчет будет идти от текущей папки
path.resolve—сложить два пути(или вернуть второй, если он абсолютный)
path.relativize — найти дорогу от первого ко второму, кидает IllegalArgumentException, если только один входной Path — абсолютный
У Path есть методы relativize и compareTo, они принимают на вход только пути(но не строки). остальные методы умеют в перегруженные версии
Path — иммутабельный
symbolicLink — может указывать на директорию. не стоит этого забывать
BasicFileAttributes - только читает.BasicFileAttributesView — умеет менять.
По умолчанию, атрибуты копируются
Лямбда метода find должна принимать на вход файл и его читабельные аттрибуты
Есть методы Files.copy и Files.move
Первый элемент после "/" или "c:\\" считается нулевым
path.getName() может кидать только IllegalArgumentException(никаких ArrayOutOfBounds)
Методы path.startsWith(x) и path.endsWith(x) требуют, чтобы x был полностью одной из частей path(если путь абсолютный — то и вместе с символом абсолютности)
Для ошибок в классах nio используются специальные классы-исключения из пакета nio

JDBC
Драйвер лежит в META-INF/service
При создании подключения сначала идёт тип скроллинга, а потом — чтение/запись
Надо проверять обработку SQLException
Закрытый ResultSet бросает SQLException при попытке обращения
Методы бегания по результатам возвращают true только если курсор показывает на данные
ResultSetMetaData можно получить вызвав result.getMetaData(). Оттуда можно получить всякие подробности о колонках.
CallableStatement нужна для вызова хранимок
PreparedStament позволяет использовать методы setBlob(можно запихнуть внутрь Stream) или setClob(можно запихнуть внутрь Reader). Кроме того, есть специальные классы Blob и Clob(для бинарников и больших текстовых данных соответственно)
Драйвер обязательно должен мочь в SQL92
Чтобы изменения отправлялись в базу, должен быть включен connection.setAutoCommit(true/false)(всегда включен по умолчанию), или надо руками вызывать connection.commit()
И столбцы и строки считаются с единицы
Метод роллбэк(класс Coonnection) отматывает все незакоммиченные изменения. Можно создать сэйвпойнт и передать его в роллбэк, тогда отмотаются все изменения после сейвпойнта
rs.getString(i)  может вернуть результат из колонки любого типа
statement.setMaxRows(i) — есть такой метод. ограничивает размер результата

Посмотреть Collectors.summarizingInt()
